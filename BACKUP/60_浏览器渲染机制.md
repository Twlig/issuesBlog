# [浏览器渲染机制](https://github.com/Twlig/issuesBlog/issues/60)

## 1.浏览器主要组成与浏览器线程

### 1.1浏览器组件

- **界面控件** – 包括地址栏，前进后退，书签菜单等窗口上除了网页显示区域以外的部分
- **浏览器引擎** – 查询与操作渲染引擎的接口
- **渲染引擎** – 负责显示请求的内容。比如请求到HTML, 它会负责解析HTML、CSS并将结果显示到窗口中
- **网络** – 用于网络请求, 如HTTP请求。它包括平台无关的接口和各平台独立的实现
- **UI后端** – 绘制基础元件，如组合框与窗口。它提供平台无关的接口，内部使用操作系统的相应实现
- **JS解释器** - 用于解析执行JavaScript代码
- **数据存储持久层** - 浏览器需要把所有数据存到硬盘上，如cookies。新的HTML5规范规定了一个完整（虽然轻量级）的浏览器中的数据库 `web database`

![image](https://user-images.githubusercontent.com/22440467/159203415-8726a0ac-3516-46ef-9852-d34d5a59994d.png)

**注意**：chrome浏览器与其他浏览器不同，chrome使用多个渲染引擎实例，每个Tab页一个，即每个Tab都是一个独立进程。

### 1.2 浏览器中的进程与线程

Chrome浏览器使用多个进程来隔离不同的网页，在Chrome中打开一个网页相当于起了一个进程，每个tab网页都有由其独立的渲染引擎实例。因为如果非多进程的话，如果浏览器中的一个tab网页崩溃，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的，所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源，所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。

在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

#### 1. GUI 渲染线程

GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的，也就是说被**冻结**了.

#### 2. JavaScript引擎线程

JS为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JS是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。

GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

#### 3. 定时触发器线程

浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

#### 4. 事件触发线程

当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。

#### 5. 异步http请求线程

在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。



## 2. 渲染过程

### 2.1 渲染流程

用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，其中渲染流程图：

[![image](https://user-images.githubusercontent.com/52184434/114830115-754a7500-9dfe-11eb-9cee-e40d3f5c25fe.png)

渲染流程有四个主要步骤：

1. **解析HTML生成DOM树** - 渲染引擎首先解析HTML文档，生成DOM树
2. **构建Render树** - 接下来不管是内联式，外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树，根据DOM树与CSSOM树生成另外一棵用于渲染的树-渲染树(Render tree)，
3. **布局Render树** - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置
4. **绘制Render树** - 最后遍历渲染树并用UI后端层将每一个节点绘制出来

### 2.2 渲染细节

#### 1. 生成DOM树

DOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。DOM树的根节点就是document对象。DOM树的生成过程中可能会被CSS和JS的加载执行阻塞。

#### 2. 生成Render树

生成DOM树的同时会生成样式结构体CSSOM（CSS Object Model）Tree，再根据CSSOM和DOM树构造渲染树Render Tree，渲染树包含带有颜色，尺寸等显示属性的矩形，这些矩形的顺序与显示顺序基本一致。从MVC的角度来说，可以将Render树看成是V，DOM树与CSSOM树看成是M，C则是具体的调度者，比HTMLDocumentParser等。

可以这么说，没有DOM树就没有Render树，但是它们之间不是简单的一对一的关系。Render树是用于显示，那不可见的元素当然不会在这棵树中出现了，譬如 `<head>`。除此之外，**display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这Render树里**。

#### 3. DOM树与Render树

DOM对象类型很丰富，什么head、title、div，而Render树相对来说就比较单一了，毕竟它的职责就是为了以后的显示渲染用嘛。Render树的每一个节点我们叫它渲染器renderer。

**renderer与DOM元素是相对应的，但并不是一一对应**，有些DOM元素没有对应的renderer，而有些DOM元素却对应了好几个renderer，对应多个renderer的情况是普遍存在的，就是为了解决一个renderer描述不清楚如何显示出来的问题，譬如有下拉列表的select元素，我们就需要三个renderer：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。

#### 4. 布局与绘制

Render树生成后，进行显示元素布局。当renderer构造出来并添加到**Render树上之后，它并没有位置跟大小信息**，为它确定这些信息的过程，接下来是**布局**(layout)。

浏览器进行页面布局基本过程是以浏览器可见区域为画布，左上角为 `(0,0)`基础坐标，从左到右，从上到下从DOM的根节点开始画，首先确定显示元素的大小跟位置，此过程是通过浏览器计算出来的，用户CSS中定义的量未必就是浏览器实际采用的量。如果显示元素有子元素得先去确定子元素的显示信息。

布局阶段输出的结果称为box盒模型（width,height,margin,padding,border,left,top,…），盒模型精确表示了每一个元素的位置和大小，并且所有相对度量单位此时都**转化为了绝对单位**。

在**绘制**(painting)阶段，渲染引擎会遍历Render树，并调用renderer的 paint() 方法，将renderer的内容显示在屏幕上。绘制工作是使用UI后端组件完成的。

#### 5. 回流与重绘

**回流**(reflow)：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从 `<html>`这个 `root frame` 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。

**重绘**(repaint)：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

每次Reflow，Repaint后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。**Reflow 的成本比 Repaint 的成本高得多**。

**reflow与repaint的时机**：

1. `display:none` 会触发 reflow，而 `visibility:hidden` 只会触发 repaint，因为没有发生位置变化。
2. 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。
3. 有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。



## 3. 关键渲染路径与阻塞渲染

在浏览器拿到HTML、CSS、JS等外部资源到渲染出页面的过程，有一个重要的概念**关键渲染路径**（Critical Rendering Path）。例如为了保障首屏内容的最快速显示，通常会提到一个渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。了解原理可以让我们更好的优化关键渲染路径，从而获得更好的用户体验。

现代浏览器总是**并行加载资源**，例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。

### 3.1 css

渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，**HTML 和 CSS 都是阻塞渲染的资源**。

关于CSS加载的阻塞情况：

1. css加载不会阻塞DOM树的解析
2. css加载会阻塞DOM树的渲染，即阻塞render树生成。
3. css加载会阻塞后面js语句的执行

### 3.2 JavaScript

如果没有 defer 或 async，浏览器会**立即加载并执行指定的脚本**，不等待后续载入的HTML元素，读到就加载并执行。

- defer

  defer 属性表示延迟执行引入 JavaScript。载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。

- async

  async 属性表示异步执行引入的 JavaScript。与 defer 的区别在于，如果已经加载好，就会开始执行。因此有可能阻塞HTML的解析。

**注意** ：async 与 defer 属性对于 inline-script 都是无效的

```html
<script async>console.log("1")</script>  <!--无效-->
<script defer>console.log("2")</script>  <!--无效-->
```



总之：

- CSS和HTML在解析过程是可以并行的。

- 但CSS和HTML解析都会**阻塞渲染**，因为构建render树要求同时具有 DOM 和 CSSOM。
- JS解析和HTML解析是互相阻塞的资源，看谁先触发执行
- JS和css不会相互阻塞。（推测）
- 因此，js文件需要访问DOM节点时，需要放在HTML尾部，让HTML先被解析成DOM树，为防止js文件访问不到DOM节点。



## 4. 优化渲染性能

结合渲染流程，可以针对性的优化渲染性能：

1. 优化JS的执行效率
2. 降低样式计算的范围和复杂度
3. 避免大规模、复杂的布局
4. 简化绘制的复杂度、减少绘制区域
5. 优先使用渲染层合并属性、控制层数量
6. 对用户输入事件的处理函数去抖动（移动设备）



原文链接: [[浏览器渲染机制](https://cloud.tencent.com/developer/article/1495980)](